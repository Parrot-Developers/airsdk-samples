/**
 * Copyright (c) 2023 Parrot Drones SAS
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * * Redistributions of source code must retain the above copyright
 *   notice, this list of conditions and the following disclaimer.
 * * Redistributions in binary form must reproduce the above copyright
 *   notice, this list of conditions and the following disclaimer in
 *   the documentation and/or other materials provided with the
 *   distribution.
 * * Neither the name of the Parrot Company nor the names
 *   of its contributors may be used to endorse or promote products
 *   derived from this software without specific prior written
 *   permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * PARROT COMPANY BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
#pragma once

#include <airsdk/airsdk.h>
/**
 * include header file generated by protoc compiler
 */
#include <arsdk/camera2.pb-c.h>
#include <msghub_utils.h>
#include <libpomp.h>
#include <stdbool.h>

/**
 * custom state machine: one can imagine for an example mission whose goal is to
 * record a video and take a photo
 */
enum video_photo_state_machine {
	WAITING_FOR_RECORDING_CONFIG = 0,
	RECORDING_CONFIG_DONE,
	RECORDING_STARTED,
	RECORDING_STOPPED,
	PHOTO_CONFIG_DONE,
	PHOTO_SHOOT_DONE,
};

struct mission_controller ;

/**
 * @brief Create a new mission_controller object.
 *
 * @return mission_controller structure or 'NULL' in case of error
 */
struct mission_controller *mission_controller_new(struct pomp_loop *ptr_loop);

/**
 * @brief Destroy a mission_controller object.
 *
 * @param mctrl mission_controller structure.
 */
void mission_controller_destroy(struct mission_controller *mctrl);

/**
 * @brief Configure the mission_controller object.
 *
 * Set up values
 *
 * @param mctrl mission_controller structure.
 * @return 0 in case of success, negative errno value in case of error.
 */
int mission_controller_init(struct mission_controller *mctrl);

/**
 * @brief Start the mission_controller object.
 *
 * Launch the mission's state machine
 *
 * @param mctrl mission_controller structure.
 * @return 0 in case of success, negative errno value in case of error.
 */
int mission_controller_start(struct mission_controller *mctrl);

/**
 * Called once the mission_controller interface gets connected
 */
static void on_connected(bool success, void *userdata);

/**
 * Called once the mission_controller interface gets disconnected
 */
static void on_disconnected(bool success, void *userdata);

/**
 * Called each time the mission_controller interface sends a command to the
 * drone, such as the commands related to the front camera actions, land or
 * takeoff and so on
 */
static void on_sent(struct airsdk_control_itf *ctrlitf,
		    const struct arsdk_cmd *cmd,
		    bool success,
		    void *userdata);

/**
 * Called each time the mission controller interface receives an event from the
 * drone, such as the response related to the front camera actions, land or
 * takeoff and so on
 */
static void on_received(struct airsdk_control_itf *ctrlitf,
			const struct arsdk_cmd *cmd,
			void *userdata);

/**
 * start the mission controller interface, that aims to autonomously handle
 * airsdk commands and events sent to and received from the drone
 */
static int start(struct mission_controller *mctrl);

/**
 * Fcam stands for the front camera, responsible for video recording and taking
 * pictures
 */
static int cmd_fcam_start_photo(struct mission_controller *mctrl);
static int cmd_fcam_start_recording(struct mission_controller *mctrl);
static int cmd_fcam_stop_recording(struct mission_controller *mctrl);
static int cmd_fcam_set_config_photo(struct mission_controller *mctrl);
static int cmd_fcam_set_config_recording(struct mission_controller *mctrl);

/**
 * callback that aims to be called when an event is received, as response to a
 * commands we have sent thanks to the previous methods. That callback handles
 * autonomously the scrolling through the planned custom state machine of our
 * video/photo mission
 */
static int on_cmd_received(const struct arsdk_cmd *cmd,
			   struct mission_controller *mctrl);

/**
 * functions that aim to ease the understanding of the consequence of each event
 * upon the custom state machine
 */
static void react_in_sm_to_flying_state_change(
	int32_t state,
	struct mission_controller *mctrl);
static void react_to_event_state(Arsdk__Camera__Event *evt,
				 struct mission_controller *mctrl);
static void react_to_event_state_config_field_number(
	Arsdk__Camera__Event *evt,
	struct mission_controller *mctrl);
static void react_in_sm_to_camera_mode(Arsdk__Camera__CameraMode mode,
				       struct mission_controller *mctrl);
static void react_in_sm_to_event_photo(Arsdk__Camera__Event *evt,
				       struct mission_controller *mctrl);
static void react_in_sm_to_event_recording(Arsdk__Camera__Event *evt,
					   struct mission_controller *mctrl);
